for Currency Converter: can add a list for the changing monetary amounts
us_names = numeric values (100, 50, 20, 10, 5, 1, 0.25, 0.10, 0.05, 0.01)
us_bills = bills in the american system 

Positional Argument: 
  https://pyformat.info
  bc this takes any number of positional arguments, you can reference them as the number they are in the index and get answers that way. 
  
can do all kinds of magical things with the new formatting.
**to accessing the list: use the value
**to access the string, use the key

help dict() - same as yesterday

copy creates a shallow copy, what is a shallow copy?
UPDATE DICTIONARIES
they have all the keys in an iterable item
Update will take the keys and replace the keys that collide with the old keys and/or give them new keys
copy - creates a duplicate of the list
can look at id by writing id(NAME OF LIST/STRING)
dictionary.UPDATE will add the new one

.keys will give you the keys of the list
.values will give you the values of the list
dont rely on them to give you the identifiers
.items will give you list and values

methods lacking __tuples__ are intended for us to use. 
help(dictonary.items().isdisjoint)

dictionaries remove confusion and reduce the number of things required to think about

enumerate(dictionary.item()) will show you where it lives in the string

help on class list
__iter__ will let you make it a list
in place - 

[i for i in range(13)]

'as' will give you aliases for different things
pprint - pretty print. sorts the list automatically

datetime.datetime = this is unfortunately named

how does comp know the even/odd numbers? have to give it a math equation- is this a truth?
True is greater than False, 
what happens in a return function that does not have a type. it returns NoneType

Booleans, strings, 
Above is all for lists and data structures.

BE CONSISTENT IN THE CODE>DO NOT SPEND EXTRA BANDWIDTH ON FIGURING IT OUT

todays lesson: sorted, different dictionaries for lists, order, list comprehensions
